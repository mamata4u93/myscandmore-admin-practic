{"ast":null,"code":"/**\n * react-query\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"react\"), require(\"use-sync-external-store/shim\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\", \"use-sync-external-store/shim\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).ReactQuery = {}, t.React, t.shim);\n}(this, function (t, e, s) {\n  \"use strict\";\n\n  function r(t) {\n    if (t && t.__esModule) return t;\n    var e = Object.create(null);\n    return t && Object.keys(t).forEach(function (s) {\n      if (\"default\" !== s) {\n        var r = Object.getOwnPropertyDescriptor(t, s);\n        Object.defineProperty(e, s, r.get ? r : {\n          enumerable: !0,\n          get: function () {\n            return t[s];\n          }\n        });\n      }\n    }), e.default = t, Object.freeze(e);\n  }\n\n  var i = r(e);\n  /**\n     * query-core\n     *\n     * Copyright (c) TanStack\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE.md file in the root directory of this source tree.\n     *\n     * @license MIT\n     */\n\n  class n {\n    constructor() {\n      this.listeners = [], this.subscribe = this.subscribe.bind(this);\n    }\n\n    subscribe(t) {\n      return this.listeners.push(t), this.onSubscribe(), () => {\n        this.listeners = this.listeners.filter(e => e !== t), this.onUnsubscribe();\n      };\n    }\n\n    hasListeners() {\n      return this.listeners.length > 0;\n    }\n\n    onSubscribe() {}\n\n    onUnsubscribe() {}\n\n  }\n\n  const a = \"undefined\" == typeof window;\n\n  function o() {}\n\n  function u(t) {\n    return \"number\" == typeof t && t >= 0 && t !== 1 / 0;\n  }\n\n  function c(t, e) {\n    return t.filter(t => -1 === e.indexOf(t));\n  }\n\n  function h(t, e) {\n    return Math.max(t + (e || 0) - Date.now(), 0);\n  }\n\n  function l(t, e, s) {\n    return S(t) ? \"function\" == typeof e ? { ...s,\n      queryKey: t,\n      queryFn: e\n    } : { ...e,\n      queryKey: t\n    } : t;\n  }\n\n  function d(t, e, s) {\n    return S(t) ? \"function\" == typeof e ? { ...s,\n      mutationKey: t,\n      mutationFn: e\n    } : { ...e,\n      mutationKey: t\n    } : \"function\" == typeof t ? { ...e,\n      mutationFn: t\n    } : { ...t\n    };\n  }\n\n  function f(t, e, s) {\n    return S(t) ? [{ ...e,\n      queryKey: t\n    }, s] : [t || {}, e];\n  }\n\n  function p(t, e, s) {\n    return S(t) ? [{ ...e,\n      mutationKey: t\n    }, s] : [t || {}, e];\n  }\n\n  function y(t, e) {\n    const {\n      type: s = \"all\",\n      exact: r,\n      fetchStatus: i,\n      predicate: n,\n      queryKey: a,\n      stale: o\n    } = t;\n    if (S(a)) if (r) {\n      if (e.queryHash !== m(a, e.options)) return !1;\n    } else if (!g(e.queryKey, a)) return !1;\n\n    if (\"all\" !== s) {\n      const t = e.isActive();\n      if (\"active\" === s && !t) return !1;\n      if (\"inactive\" === s && t) return !1;\n    }\n\n    return (\"boolean\" != typeof o || e.isStale() === o) && (void 0 === i || i === e.state.fetchStatus) && !(n && !n(e));\n  }\n\n  function v(t, e) {\n    const {\n      exact: s,\n      fetching: r,\n      predicate: i,\n      mutationKey: n\n    } = t;\n\n    if (S(n)) {\n      if (!e.options.mutationKey) return !1;\n\n      if (s) {\n        if (b(e.options.mutationKey) !== b(n)) return !1;\n      } else if (!g(e.options.mutationKey, n)) return !1;\n    }\n\n    return (\"boolean\" != typeof r || \"loading\" === e.state.status === r) && !(i && !i(e));\n  }\n\n  function m(t, e) {\n    return ((null == e ? void 0 : e.queryKeyHashFn) || b)(t);\n  }\n\n  function b(t) {\n    return JSON.stringify(t, (t, e) => q(e) ? Object.keys(e).sort().reduce((t, s) => (t[s] = e[s], t), {}) : e);\n  }\n\n  function g(t, e) {\n    return O(t, e);\n  }\n\n  function O(t, e) {\n    return t === e || typeof t == typeof e && !(!t || !e || \"object\" != typeof t || \"object\" != typeof e) && !Object.keys(e).some(s => !O(t[s], e[s]));\n  }\n\n  function C(t, e) {\n    if (t === e) return t;\n    const s = R(t) && R(e);\n\n    if (s || q(t) && q(e)) {\n      const r = s ? t.length : Object.keys(t).length,\n            i = s ? e : Object.keys(e),\n            n = i.length,\n            a = s ? [] : {};\n      let o = 0;\n\n      for (let r = 0; r < n; r++) {\n        const n = s ? r : i[r];\n        a[n] = C(t[n], e[n]), a[n] === t[n] && o++;\n      }\n\n      return r === n && o === r ? t : a;\n    }\n\n    return e;\n  }\n\n  function R(t) {\n    return Array.isArray(t) && t.length === Object.keys(t).length;\n  }\n\n  function q(t) {\n    if (!P(t)) return !1;\n    const e = t.constructor;\n    if (void 0 === e) return !0;\n    const s = e.prototype;\n    return !!P(s) && !!s.hasOwnProperty(\"isPrototypeOf\");\n  }\n\n  function P(t) {\n    return \"[object Object]\" === Object.prototype.toString.call(t);\n  }\n\n  function S(t) {\n    return Array.isArray(t);\n  }\n\n  function Q(t) {\n    return new Promise(e => {\n      setTimeout(e, t);\n    });\n  }\n\n  function E(t) {\n    Q(0).then(t);\n  }\n\n  function x(t, e, s) {\n    return null != s.isDataEqual && s.isDataEqual(t, e) ? t : !1 !== s.structuralSharing ? C(t, e) : e;\n  }\n\n  const M = new class extends n {\n    constructor() {\n      super(), this.setup = t => {\n        if (!a && window.addEventListener) {\n          const e = () => t();\n\n          return window.addEventListener(\"visibilitychange\", e, !1), window.addEventListener(\"focus\", e, !1), () => {\n            window.removeEventListener(\"visibilitychange\", e), window.removeEventListener(\"focus\", e);\n          };\n        }\n      };\n    }\n\n    onSubscribe() {\n      this.cleanup || this.setEventListener(this.setup);\n    }\n\n    onUnsubscribe() {\n      var t;\n      this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n    }\n\n    setEventListener(t) {\n      var e;\n      this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(t => {\n        \"boolean\" == typeof t ? this.setFocused(t) : this.onFocus();\n      });\n    }\n\n    setFocused(t) {\n      this.focused = t, t && this.onFocus();\n    }\n\n    onFocus() {\n      this.listeners.forEach(t => {\n        t();\n      });\n    }\n\n    isFocused() {\n      return \"boolean\" == typeof this.focused ? this.focused : \"undefined\" == typeof document || [void 0, \"visible\", \"prerender\"].includes(document.visibilityState);\n    }\n\n  }();\n  const w = new class extends n {\n    constructor() {\n      super(), this.setup = t => {\n        if (!a && window.addEventListener) {\n          const e = () => t();\n\n          return window.addEventListener(\"online\", e, !1), window.addEventListener(\"offline\", e, !1), () => {\n            window.removeEventListener(\"online\", e), window.removeEventListener(\"offline\", e);\n          };\n        }\n      };\n    }\n\n    onSubscribe() {\n      this.cleanup || this.setEventListener(this.setup);\n    }\n\n    onUnsubscribe() {\n      var t;\n      this.hasListeners() || (null == (t = this.cleanup) || t.call(this), this.cleanup = void 0);\n    }\n\n    setEventListener(t) {\n      var e;\n      this.setup = t, null == (e = this.cleanup) || e.call(this), this.cleanup = t(t => {\n        \"boolean\" == typeof t ? this.setOnline(t) : this.onOnline();\n      });\n    }\n\n    setOnline(t) {\n      this.online = t, t && this.onOnline();\n    }\n\n    onOnline() {\n      this.listeners.forEach(t => {\n        t();\n      });\n    }\n\n    isOnline() {\n      return \"boolean\" == typeof this.online ? this.online : \"undefined\" == typeof navigator || void 0 === navigator.onLine || navigator.onLine;\n    }\n\n  }();\n\n  function F(t) {\n    return Math.min(1e3 * 2 ** t, 3e4);\n  }\n\n  function A(t) {\n    return \"online\" !== (null != t ? t : \"online\") || w.isOnline();\n  }\n\n  class D {\n    constructor(t) {\n      this.revert = null == t ? void 0 : t.revert, this.silent = null == t ? void 0 : t.silent;\n    }\n\n  }\n\n  function I(t) {\n    return t instanceof D;\n  }\n\n  function U(t) {\n    let e,\n        s,\n        r,\n        i = !1,\n        n = 0,\n        a = !1;\n\n    const o = new Promise((t, e) => {\n      s = t, r = e;\n    }),\n          u = () => !M.isFocused() || \"always\" !== t.networkMode && !w.isOnline(),\n          c = r => {\n      a || (a = !0, null == t.onSuccess || t.onSuccess(r), null == e || e(), s(r));\n    },\n          h = s => {\n      a || (a = !0, null == t.onError || t.onError(s), null == e || e(), r(s));\n    },\n          l = () => new Promise(s => {\n      e = t => {\n        if (a || !u()) return s(t);\n      }, null == t.onPause || t.onPause();\n    }).then(() => {\n      e = void 0, a || null == t.onContinue || t.onContinue();\n    }),\n          d = () => {\n      if (a) return;\n      let e;\n\n      try {\n        e = t.fn();\n      } catch (t) {\n        e = Promise.reject(t);\n      }\n\n      Promise.resolve(e).then(c).catch(e => {\n        var s, r;\n        if (a) return;\n        const o = null != (s = t.retry) ? s : 3,\n              c = null != (r = t.retryDelay) ? r : F,\n              f = \"function\" == typeof c ? c(n, e) : c,\n              p = !0 === o || \"number\" == typeof o && n < o || \"function\" == typeof o && o(n, e);\n        !i && p ? (n++, null == t.onFail || t.onFail(n, e), Q(f).then(() => {\n          if (u()) return l();\n        }).then(() => {\n          i ? h(e) : d();\n        })) : h(e);\n      });\n    };\n\n    return A(t.networkMode) ? d() : l().then(d), {\n      promise: o,\n      cancel: e => {\n        a || (h(new D(e)), null == t.abort || t.abort());\n      },\n      continue: () => {\n        null == e || e();\n      },\n      cancelRetry: () => {\n        i = !0;\n      },\n      continueRetry: () => {\n        i = !1;\n      }\n    };\n  }\n\n  const T = console;\n\n  const K = function () {\n    let t = [],\n        e = 0,\n        s = t => {\n      t();\n    },\n        r = t => {\n      t();\n    };\n\n    const i = r => {\n      e ? t.push(r) : E(() => {\n        s(r);\n      });\n    },\n          n = () => {\n      const e = t;\n      t = [], e.length && E(() => {\n        r(() => {\n          e.forEach(t => {\n            s(t);\n          });\n        });\n      });\n    };\n\n    return {\n      batch: t => {\n        let s;\n        e++;\n\n        try {\n          s = t();\n        } finally {\n          e--, e || n();\n        }\n\n        return s;\n      },\n      batchCalls: t => function () {\n        for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n          e[_key] = arguments[_key];\n        }\n\n        i(() => {\n          t(...e);\n        });\n      },\n      schedule: i,\n      setNotifyFunction: t => {\n        s = t;\n      },\n      setBatchNotifyFunction: t => {\n        r = t;\n      }\n    };\n  }();\n\n  class k {\n    destroy() {\n      this.clearGcTimeout();\n    }\n\n    scheduleGc() {\n      this.clearGcTimeout(), u(this.cacheTime) && (this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime));\n    }\n\n    updateCacheTime(t) {\n      this.cacheTime = Math.max(this.cacheTime || 0, null != t ? t : a ? 1 / 0 : 3e5);\n    }\n\n    clearGcTimeout() {\n      this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0);\n    }\n\n  }\n\n  class L extends k {\n    constructor(t) {\n      super(), this.abortSignalConsumed = !1, this.defaultOptions = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.cache = t.cache, this.logger = t.logger || T, this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.initialState = t.state || function (t) {\n        const e = \"function\" == typeof t.initialData ? t.initialData() : t.initialData,\n              s = void 0 !== t.initialData ? \"function\" == typeof t.initialDataUpdatedAt ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0,\n              r = void 0 !== e;\n        return {\n          data: e,\n          dataUpdateCount: 0,\n          dataUpdatedAt: r ? null != s ? s : Date.now() : 0,\n          error: null,\n          errorUpdateCount: 0,\n          errorUpdatedAt: 0,\n          fetchFailureCount: 0,\n          fetchMeta: null,\n          isInvalidated: !1,\n          status: r ? \"success\" : \"loading\",\n          fetchStatus: \"idle\"\n        };\n      }(this.options), this.state = this.initialState, this.meta = t.meta;\n    }\n\n    setOptions(t) {\n      this.options = { ...this.defaultOptions,\n        ...t\n      }, this.meta = null == t ? void 0 : t.meta, this.updateCacheTime(this.options.cacheTime);\n    }\n\n    optionalRemove() {\n      this.observers.length || \"idle\" !== this.state.fetchStatus || this.cache.remove(this);\n    }\n\n    setData(t, e) {\n      const s = x(this.state.data, t, this.options);\n      return this.dispatch({\n        data: s,\n        type: \"success\",\n        dataUpdatedAt: null == e ? void 0 : e.updatedAt,\n        manual: null == e ? void 0 : e.manual\n      }), s;\n    }\n\n    setState(t, e) {\n      this.dispatch({\n        type: \"setState\",\n        state: t,\n        setStateOptions: e\n      });\n    }\n\n    cancel(t) {\n      var e;\n      const s = this.promise;\n      return null == (e = this.retryer) || e.cancel(t), s ? s.then(o).catch(o) : Promise.resolve();\n    }\n\n    destroy() {\n      super.destroy(), this.cancel({\n        silent: !0\n      });\n    }\n\n    reset() {\n      this.destroy(), this.setState(this.initialState);\n    }\n\n    isActive() {\n      return this.observers.some(t => !1 !== t.options.enabled);\n    }\n\n    isDisabled() {\n      return this.getObserversCount() > 0 && !this.isActive();\n    }\n\n    isStale() {\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(t => t.getCurrentResult().isStale);\n    }\n\n    isStaleByTime() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || !h(this.state.dataUpdatedAt, t);\n    }\n\n    onFocus() {\n      var t;\n      const e = this.observers.find(t => t.shouldFetchOnWindowFocus());\n      e && e.refetch({\n        cancelRefetch: !1\n      }), null == (t = this.retryer) || t.continue();\n    }\n\n    onOnline() {\n      var t;\n      const e = this.observers.find(t => t.shouldFetchOnReconnect());\n      e && e.refetch({\n        cancelRefetch: !1\n      }), null == (t = this.retryer) || t.continue();\n    }\n\n    addObserver(t) {\n      -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer: t\n      }));\n    }\n\n    removeObserver(t) {\n      -1 !== this.observers.indexOf(t) && (this.observers = this.observers.filter(e => e !== t), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({\n        revert: !0\n      }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer: t\n      }));\n    }\n\n    getObserversCount() {\n      return this.observers.length;\n    }\n\n    invalidate() {\n      this.state.isInvalidated || this.dispatch({\n        type: \"invalidate\"\n      });\n    }\n\n    fetch(t, e) {\n      var s, r;\n      if (\"idle\" !== this.state.fetchStatus) if (this.state.dataUpdatedAt && null != e && e.cancelRefetch) this.cancel({\n        silent: !0\n      });else if (this.promise) {\n        var i;\n        return null == (i = this.retryer) || i.continueRetry(), this.promise;\n      }\n\n      if (t && this.setOptions(t), !this.options.queryFn) {\n        const t = this.observers.find(t => t.options.queryFn);\n        t && this.setOptions(t.options);\n      }\n\n      Array.isArray(this.options.queryKey);\n\n      const n = function () {\n        if (\"function\" == typeof AbortController) return new AbortController();\n      }(),\n            a = {\n        queryKey: this.queryKey,\n        pageParam: void 0,\n        meta: this.meta\n      },\n            o = t => {\n        Object.defineProperty(t, \"signal\", {\n          enumerable: !0,\n          get: () => {\n            if (n) return this.abortSignalConsumed = !0, n.signal;\n          }\n        });\n      };\n\n      o(a);\n      const u = {\n        fetchOptions: e,\n        options: this.options,\n        queryKey: this.queryKey,\n        state: this.state,\n        fetchFn: () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(a)) : Promise.reject(\"Missing queryFn\"),\n        meta: this.meta\n      };\n      var c;\n      (o(u), null == (s = this.options.behavior) || s.onFetch(u), this.revertState = this.state, \"idle\" === this.state.fetchStatus || this.state.fetchMeta !== (null == (r = u.fetchOptions) ? void 0 : r.meta)) && this.dispatch({\n        type: \"fetch\",\n        meta: null == (c = u.fetchOptions) ? void 0 : c.meta\n      });\n\n      const h = t => {\n        var e, s;\n        (I(t) && t.silent || this.dispatch({\n          type: \"error\",\n          error: t\n        }), I(t)) || null == (e = (s = this.cache.config).onError) || e.call(s, t, this);\n        this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;\n      };\n\n      return this.retryer = U({\n        fn: u.fetchFn,\n        abort: null == n ? void 0 : n.abort.bind(n),\n        onSuccess: t => {\n          var e, s;\n          void 0 !== t ? (this.setData(t), null == (e = (s = this.cache.config).onSuccess) || e.call(s, t, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1) : h(new Error(\"Query data cannot be undefined\"));\n        },\n        onError: h,\n        onFail: () => {\n          this.dispatch({\n            type: \"failed\"\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: \"pause\"\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: \"continue\"\n          });\n        },\n        retry: u.options.retry,\n        retryDelay: u.options.retryDelay,\n        networkMode: u.options.networkMode\n      }), this.promise = this.retryer.promise, this.promise;\n    }\n\n    dispatch(t) {\n      this.state = (e => {\n        var s, r;\n\n        switch (t.type) {\n          case \"failed\":\n            return { ...e,\n              fetchFailureCount: e.fetchFailureCount + 1\n            };\n\n          case \"pause\":\n            return { ...e,\n              fetchStatus: \"paused\"\n            };\n\n          case \"continue\":\n            return { ...e,\n              fetchStatus: \"fetching\"\n            };\n\n          case \"fetch\":\n            return { ...e,\n              fetchFailureCount: 0,\n              fetchMeta: null != (s = t.meta) ? s : null,\n              fetchStatus: A(this.options.networkMode) ? \"fetching\" : \"paused\",\n              ...(!e.dataUpdatedAt && {\n                error: null,\n                status: \"loading\"\n              })\n            };\n\n          case \"success\":\n            return { ...e,\n              data: t.data,\n              dataUpdateCount: e.dataUpdateCount + 1,\n              dataUpdatedAt: null != (r = t.dataUpdatedAt) ? r : Date.now(),\n              error: null,\n              isInvalidated: !1,\n              status: \"success\",\n              ...(!t.manual && {\n                fetchStatus: \"idle\",\n                fetchFailureCount: 0\n              })\n            };\n\n          case \"error\":\n            const i = t.error;\n            return I(i) && i.revert && this.revertState ? { ...this.revertState\n            } : { ...e,\n              error: i,\n              errorUpdateCount: e.errorUpdateCount + 1,\n              errorUpdatedAt: Date.now(),\n              fetchFailureCount: e.fetchFailureCount + 1,\n              fetchStatus: \"idle\",\n              status: \"error\"\n            };\n\n          case \"invalidate\":\n            return { ...e,\n              isInvalidated: !0\n            };\n\n          case \"setState\":\n            return { ...e,\n              ...t.state\n            };\n        }\n      })(this.state), K.batch(() => {\n        this.observers.forEach(e => {\n          e.onQueryUpdate(t);\n        }), this.cache.notify({\n          query: this,\n          type: \"updated\",\n          action: t\n        });\n      });\n    }\n\n  }\n\n  class j extends n {\n    constructor(t) {\n      super(), this.config = t || {}, this.queries = [], this.queriesMap = {};\n    }\n\n    build(t, e, s) {\n      var r;\n      const i = e.queryKey,\n            n = null != (r = e.queryHash) ? r : m(i, e);\n      let a = this.get(n);\n      return a || (a = new L({\n        cache: this,\n        logger: t.getLogger(),\n        queryKey: i,\n        queryHash: n,\n        options: t.defaultQueryOptions(e),\n        state: s,\n        defaultOptions: t.getQueryDefaults(i),\n        meta: e.meta\n      }), this.add(a)), a;\n    }\n\n    add(t) {\n      this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({\n        type: \"added\",\n        query: t\n      }));\n    }\n\n    remove(t) {\n      const e = this.queriesMap[t.queryHash];\n      e && (t.destroy(), this.queries = this.queries.filter(e => e !== t), e === t && delete this.queriesMap[t.queryHash], this.notify({\n        type: \"removed\",\n        query: t\n      }));\n    }\n\n    clear() {\n      K.batch(() => {\n        this.queries.forEach(t => {\n          this.remove(t);\n        });\n      });\n    }\n\n    get(t) {\n      return this.queriesMap[t];\n    }\n\n    getAll() {\n      return this.queries;\n    }\n\n    find(t, e) {\n      const [s] = f(t, e);\n      return void 0 === s.exact && (s.exact = !0), this.queries.find(t => y(s, t));\n    }\n\n    findAll(t, e) {\n      const [s] = f(t, e);\n      return Object.keys(s).length > 0 ? this.queries.filter(t => y(s, t)) : this.queries;\n    }\n\n    notify(t) {\n      K.batch(() => {\n        this.listeners.forEach(e => {\n          e(t);\n        });\n      });\n    }\n\n    onFocus() {\n      K.batch(() => {\n        this.queries.forEach(t => {\n          t.onFocus();\n        });\n      });\n    }\n\n    onOnline() {\n      K.batch(() => {\n        this.queries.forEach(t => {\n          t.onOnline();\n        });\n      });\n    }\n\n  }\n\n  class H extends k {\n    constructor(t) {\n      super(), this.options = { ...t.defaultOptions,\n        ...t.options\n      }, this.mutationId = t.mutationId, this.mutationCache = t.mutationCache, this.logger = t.logger || T, this.observers = [], this.state = t.state || N(), this.meta = t.meta, this.updateCacheTime(this.options.cacheTime), this.scheduleGc();\n    }\n\n    setState(t) {\n      this.dispatch({\n        type: \"setState\",\n        state: t\n      });\n    }\n\n    addObserver(t) {\n      -1 === this.observers.indexOf(t) && (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer: t\n      }));\n    }\n\n    removeObserver(t) {\n      this.observers = this.observers.filter(e => e !== t), this.scheduleGc(), this.mutationCache.notify({\n        type: \"observerRemoved\",\n        mutation: this,\n        observer: t\n      });\n    }\n\n    optionalRemove() {\n      this.observers.length || (\"loading\" === this.state.status ? this.scheduleGc() : this.mutationCache.remove(this));\n    }\n\n    continue() {\n      return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute();\n    }\n\n    async execute() {\n      const t = () => {\n        var t;\n        return this.retryer = U({\n          fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject(\"No mutationFn found\"),\n          onFail: () => {\n            this.dispatch({\n              type: \"failed\"\n            });\n          },\n          onPause: () => {\n            this.dispatch({\n              type: \"pause\"\n            });\n          },\n          onContinue: () => {\n            this.dispatch({\n              type: \"continue\"\n            });\n          },\n          retry: null != (t = this.options.retry) ? t : 0,\n          retryDelay: this.options.retryDelay,\n          networkMode: this.options.networkMode\n        }), this.retryer.promise;\n      },\n            e = \"loading\" === this.state.status;\n\n      try {\n        var s, r, i, n, a, o;\n\n        if (!e) {\n          var u, c, h, l;\n          this.dispatch({\n            type: \"loading\",\n            variables: this.options.variables\n          }), null == (u = (c = this.mutationCache.config).onMutate) || u.call(c, this.state.variables, this);\n          const t = await (null == (h = (l = this.options).onMutate) ? void 0 : h.call(l, this.state.variables));\n          t !== this.state.context && this.dispatch({\n            type: \"loading\",\n            context: t,\n            variables: this.state.variables\n          });\n        }\n\n        const d = await t();\n        return null == (s = (r = this.mutationCache.config).onSuccess) || s.call(r, d, this.state.variables, this.state.context, this), await (null == (i = (n = this.options).onSuccess) ? void 0 : i.call(n, d, this.state.variables, this.state.context)), await (null == (a = (o = this.options).onSettled) ? void 0 : a.call(o, d, null, this.state.variables, this.state.context)), this.dispatch({\n          type: \"success\",\n          data: d\n        }), d;\n      } catch (t) {\n        try {\n          var d, f, p, y, v, m;\n          throw null == (d = (f = this.mutationCache.config).onError) || d.call(f, t, this.state.variables, this.state.context, this), await (null == (p = (y = this.options).onError) ? void 0 : p.call(y, t, this.state.variables, this.state.context)), await (null == (v = (m = this.options).onSettled) ? void 0 : v.call(m, void 0, t, this.state.variables, this.state.context)), t;\n        } finally {\n          this.dispatch({\n            type: \"error\",\n            error: t\n          });\n        }\n      }\n    }\n\n    dispatch(t) {\n      this.state = (e => {\n        switch (t.type) {\n          case \"failed\":\n            return { ...e,\n              failureCount: e.failureCount + 1\n            };\n\n          case \"pause\":\n            return { ...e,\n              isPaused: !0\n            };\n\n          case \"continue\":\n            return { ...e,\n              isPaused: !1\n            };\n\n          case \"loading\":\n            return { ...e,\n              context: t.context,\n              data: void 0,\n              error: null,\n              isPaused: !A(this.options.networkMode),\n              status: \"loading\",\n              variables: t.variables\n            };\n\n          case \"success\":\n            return { ...e,\n              data: t.data,\n              error: null,\n              status: \"success\",\n              isPaused: !1\n            };\n\n          case \"error\":\n            return { ...e,\n              data: void 0,\n              error: t.error,\n              failureCount: e.failureCount + 1,\n              isPaused: !1,\n              status: \"error\"\n            };\n\n          case \"setState\":\n            return { ...e,\n              ...t.state\n            };\n        }\n      })(this.state), K.batch(() => {\n        this.observers.forEach(e => {\n          e.onMutationUpdate(t);\n        }), this.mutationCache.notify({\n          mutation: this,\n          type: \"updated\",\n          action: t\n        });\n      });\n    }\n\n  }\n\n  function N() {\n    return {\n      context: void 0,\n      data: void 0,\n      error: null,\n      failureCount: 0,\n      isPaused: !1,\n      status: \"idle\",\n      variables: void 0\n    };\n  }\n\n  class B extends n {\n    constructor(t) {\n      super(), this.config = t || {}, this.mutations = [], this.mutationId = 0;\n    }\n\n    build(t, e, s) {\n      const r = new H({\n        mutationCache: this,\n        logger: t.getLogger(),\n        mutationId: ++this.mutationId,\n        options: t.defaultMutationOptions(e),\n        state: s,\n        defaultOptions: e.mutationKey ? t.getMutationDefaults(e.mutationKey) : void 0,\n        meta: e.meta\n      });\n      return this.add(r), r;\n    }\n\n    add(t) {\n      this.mutations.push(t), this.notify({\n        type: \"added\",\n        mutation: t\n      });\n    }\n\n    remove(t) {\n      this.mutations = this.mutations.filter(e => e !== t), this.notify({\n        type: \"removed\",\n        mutation: t\n      });\n    }\n\n    clear() {\n      K.batch(() => {\n        this.mutations.forEach(t => {\n          this.remove(t);\n        });\n      });\n    }\n\n    getAll() {\n      return this.mutations;\n    }\n\n    find(t) {\n      return void 0 === t.exact && (t.exact = !0), this.mutations.find(e => v(t, e));\n    }\n\n    findAll(t) {\n      return this.mutations.filter(e => v(t, e));\n    }\n\n    notify(t) {\n      K.batch(() => {\n        this.listeners.forEach(e => {\n          e(t);\n        });\n      });\n    }\n\n    resumePausedMutations() {\n      const t = this.mutations.filter(t => t.state.isPaused);\n      return K.batch(() => t.reduce((t, e) => t.then(() => e.continue().catch(o)), Promise.resolve()));\n    }\n\n  }\n\n  function G() {\n    return {\n      onFetch: t => {\n        t.fetchFn = () => {\n          var e, s, r, i, n, a;\n          const o = null == (e = t.fetchOptions) || null == (s = e.meta) ? void 0 : s.refetchPage,\n                u = null == (r = t.fetchOptions) || null == (i = r.meta) ? void 0 : i.fetchMore,\n                c = null == u ? void 0 : u.pageParam,\n                h = \"forward\" === (null == u ? void 0 : u.direction),\n                l = \"backward\" === (null == u ? void 0 : u.direction),\n                d = (null == (n = t.state.data) ? void 0 : n.pages) || [],\n                f = (null == (a = t.state.data) ? void 0 : a.pageParams) || [];\n          let p = f,\n              y = !1;\n\n          const v = t.options.queryFn || (() => Promise.reject(\"Missing queryFn\")),\n                m = (t, e, s, r) => (p = r ? [e, ...p] : [...p, e], r ? [s, ...t] : [...t, s]),\n                b = (e, s, r, i) => {\n            if (y) return Promise.reject(\"Cancelled\");\n            if (void 0 === r && !s && e.length) return Promise.resolve(e);\n            const n = {\n              queryKey: t.queryKey,\n              pageParam: r,\n              meta: t.meta\n            };\n            var a;\n            a = n, Object.defineProperty(a, \"signal\", {\n              enumerable: !0,\n              get: () => {\n                var e, s;\n                return null != (e = t.signal) && e.aborted ? y = !0 : null == (s = t.signal) || s.addEventListener(\"abort\", () => {\n                  y = !0;\n                }), t.signal;\n              }\n            });\n            const o = v(n);\n            return Promise.resolve(o).then(t => m(e, r, t, i));\n          };\n\n          let g;\n          if (d.length) {\n            if (h) {\n              const e = void 0 !== c,\n                    s = e ? c : _(t.options, d);\n              g = b(d, e, s);\n            } else if (l) {\n              const e = void 0 !== c,\n                    s = e ? c : W(t.options, d);\n              g = b(d, e, s, !0);\n            } else {\n              p = [];\n              const e = void 0 === t.options.getNextPageParam;\n              g = !o || !d[0] || o(d[0], 0, d) ? b([], e, f[0]) : Promise.resolve(m([], f[0], d[0]));\n\n              for (let s = 1; s < d.length; s++) g = g.then(r => {\n                if (!o || !d[s] || o(d[s], s, d)) {\n                  const i = e ? f[s] : _(t.options, r);\n                  return b(r, e, i);\n                }\n\n                return Promise.resolve(m(r, f[s], d[s]));\n              });\n            }\n          } else g = b([]);\n          return g.then(t => ({\n            pages: t,\n            pageParams: p\n          }));\n        };\n      }\n    };\n  }\n\n  function _(t, e) {\n    return null == t.getNextPageParam ? void 0 : t.getNextPageParam(e[e.length - 1], e);\n  }\n\n  function W(t, e) {\n    return null == t.getPreviousPageParam ? void 0 : t.getPreviousPageParam(e[0], e);\n  }\n\n  function z(t, e) {\n    if (t.getNextPageParam && Array.isArray(e)) {\n      const s = _(t, e);\n\n      return null != s && !1 !== s;\n    }\n  }\n\n  function J(t, e) {\n    if (t.getPreviousPageParam && Array.isArray(e)) {\n      const s = W(t, e);\n      return null != s && !1 !== s;\n    }\n  }\n\n  class V extends n {\n    constructor(t, e) {\n      super(), this.client = t, this.options = e, this.trackedProps = new Set(), this.selectError = null, this.bindMethods(), this.setOptions(e);\n    }\n\n    bindMethods() {\n      this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this);\n    }\n\n    onSubscribe() {\n      1 === this.listeners.length && (this.currentQuery.addObserver(this), X(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers());\n    }\n\n    onUnsubscribe() {\n      this.listeners.length || this.destroy();\n    }\n\n    shouldFetchOnReconnect() {\n      return Y(this.currentQuery, this.options, this.options.refetchOnReconnect);\n    }\n\n    shouldFetchOnWindowFocus() {\n      return Y(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n    }\n\n    destroy() {\n      this.listeners = [], this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this);\n    }\n\n    setOptions(t, e) {\n      const s = this.options,\n            r = this.currentQuery;\n      if (this.options = this.client.defaultQueryOptions(t), void 0 !== this.options.enabled && \"boolean\" != typeof this.options.enabled) throw new Error(\"Expected enabled to be a boolean\");\n      this.options.queryKey || (this.options.queryKey = s.queryKey), this.updateQuery();\n      const i = this.hasListeners();\n      i && Z(this.currentQuery, r, this.options, s) && this.executeFetch(), this.updateResult(e), !i || this.currentQuery === r && this.options.enabled === s.enabled && this.options.staleTime === s.staleTime || this.updateStaleTimeout();\n      const n = this.computeRefetchInterval();\n      !i || this.currentQuery === r && this.options.enabled === s.enabled && n === this.currentRefetchInterval || this.updateRefetchInterval(n);\n    }\n\n    getOptimisticResult(t) {\n      const e = this.client.getQueryCache().build(this.client, t);\n      return this.createResult(e, t);\n    }\n\n    getCurrentResult() {\n      return this.currentResult;\n    }\n\n    trackResult(t) {\n      const e = {};\n      return Object.keys(t).forEach(s => {\n        Object.defineProperty(e, s, {\n          configurable: !1,\n          enumerable: !0,\n          get: () => (this.trackedProps.add(s), t[s])\n        });\n      }), e;\n    }\n\n    getCurrentQuery() {\n      return this.currentQuery;\n    }\n\n    remove() {\n      this.client.getQueryCache().remove(this.currentQuery);\n    }\n\n    refetch() {\n      let {\n        refetchPage: t,\n        ...e\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.fetch({ ...e,\n        meta: {\n          refetchPage: t\n        }\n      });\n    }\n\n    fetchOptimistic(t) {\n      const e = this.client.defaultQueryOptions(t),\n            s = this.client.getQueryCache().build(this.client, e);\n      return s.isFetchingOptimistic = !0, s.fetch().then(() => this.createResult(s, e));\n    }\n\n    fetch(t) {\n      var e;\n      return this.executeFetch({ ...t,\n        cancelRefetch: null == (e = t.cancelRefetch) || e\n      }).then(() => (this.updateResult(), this.currentResult));\n    }\n\n    executeFetch(t) {\n      this.updateQuery();\n      let e = this.currentQuery.fetch(this.options, t);\n      return null != t && t.throwOnError || (e = e.catch(o)), e;\n    }\n\n    updateStaleTimeout() {\n      if (this.clearStaleTimeout(), a || this.currentResult.isStale || !u(this.options.staleTime)) return;\n      const t = h(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;\n      this.staleTimeoutId = setTimeout(() => {\n        this.currentResult.isStale || this.updateResult();\n      }, t);\n    }\n\n    computeRefetchInterval() {\n      var t;\n      return \"function\" == typeof this.options.refetchInterval ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : null != (t = this.options.refetchInterval) && t;\n    }\n\n    updateRefetchInterval(t) {\n      this.clearRefetchInterval(), this.currentRefetchInterval = t, !a && !1 !== this.options.enabled && u(this.currentRefetchInterval) && 0 !== this.currentRefetchInterval && (this.refetchIntervalId = setInterval(() => {\n        (this.options.refetchIntervalInBackground || M.isFocused()) && this.executeFetch();\n      }, this.currentRefetchInterval));\n    }\n\n    updateTimers() {\n      this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval());\n    }\n\n    clearStaleTimeout() {\n      this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0);\n    }\n\n    clearRefetchInterval() {\n      this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0);\n    }\n\n    createResult(t, e) {\n      const s = this.currentQuery,\n            r = this.options,\n            i = this.currentResult,\n            n = this.currentResultState,\n            a = this.currentResultOptions,\n            o = t !== s,\n            u = o ? t.state : this.currentQueryInitialState,\n            c = o ? this.currentResult : this.previousQueryResult,\n            {\n        state: h\n      } = t;\n      let l,\n          {\n        dataUpdatedAt: d,\n        error: f,\n        errorUpdatedAt: p,\n        fetchStatus: y,\n        status: v\n      } = h,\n          m = !1,\n          b = !1;\n\n      if (e._optimisticResults) {\n        const i = this.hasListeners(),\n              n = !i && X(t, e),\n              a = i && Z(t, s, e, r);\n        (n || a) && (y = A(t.options.networkMode) ? \"fetching\" : \"paused\", d || (v = \"loading\")), \"isRestoring\" === e._optimisticResults && (y = \"idle\");\n      }\n\n      if (e.keepPreviousData && !h.dataUpdateCount && null != c && c.isSuccess && \"error\" !== v) l = c.data, d = c.dataUpdatedAt, v = c.status, m = !0;else if (e.select && void 0 !== h.data) {\n        if (i && h.data === (null == n ? void 0 : n.data) && e.select === this.selectFn) l = this.selectResult;else try {\n          this.selectFn = e.select, l = e.select(h.data), l = x(null == i ? void 0 : i.data, l, e), this.selectResult = l, this.selectError = null;\n        } catch (t) {\n          this.selectError = t;\n        }\n      } else l = h.data;\n\n      if (void 0 !== e.placeholderData && void 0 === l && \"loading\" === v) {\n        let t;\n        if (null != i && i.isPlaceholderData && e.placeholderData === (null == a ? void 0 : a.placeholderData)) t = i.data;else if (t = \"function\" == typeof e.placeholderData ? e.placeholderData() : e.placeholderData, e.select && void 0 !== t) try {\n          t = e.select(t), t = x(null == i ? void 0 : i.data, t, e), this.selectError = null;\n        } catch (t) {\n          this.selectError = t;\n        }\n        void 0 !== t && (v = \"success\", l = t, b = !0);\n      }\n\n      this.selectError && (f = this.selectError, l = this.selectResult, p = Date.now(), v = \"error\");\n      const g = \"fetching\" === y;\n      return {\n        status: v,\n        fetchStatus: y,\n        isLoading: \"loading\" === v,\n        isSuccess: \"success\" === v,\n        isError: \"error\" === v,\n        data: l,\n        dataUpdatedAt: d,\n        error: f,\n        errorUpdatedAt: p,\n        failureCount: h.fetchFailureCount,\n        errorUpdateCount: h.errorUpdateCount,\n        isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,\n        isFetchedAfterMount: h.dataUpdateCount > u.dataUpdateCount || h.errorUpdateCount > u.errorUpdateCount,\n        isFetching: g,\n        isRefetching: g && \"loading\" !== v,\n        isLoadingError: \"error\" === v && 0 === h.dataUpdatedAt,\n        isPaused: \"paused\" === y,\n        isPlaceholderData: b,\n        isPreviousData: m,\n        isRefetchError: \"error\" === v && 0 !== h.dataUpdatedAt,\n        isStale: $(t, e),\n        refetch: this.refetch,\n        remove: this.remove\n      };\n    }\n\n    updateResult(t) {\n      const e = this.currentResult,\n            s = this.createResult(this.currentQuery, this.options);\n      if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, function (t, e) {\n        if (t && !e || e && !t) return !1;\n\n        for (const s in t) if (t[s] !== e[s]) return !1;\n\n        return !0;\n      }(s, e)) return;\n      this.currentResult = s;\n      const r = {\n        cache: !0\n      };\n      !1 !== (null == t ? void 0 : t.listeners) && (() => {\n        if (!e) return !0;\n        const {\n          notifyOnChangeProps: t\n        } = this.options;\n        if (\"all\" === t || !t && !this.trackedProps.size) return !0;\n        const s = new Set(null != t ? t : this.trackedProps);\n        return this.options.useErrorBoundary && s.add(\"error\"), Object.keys(this.currentResult).some(t => {\n          const r = t;\n          return this.currentResult[r] !== e[r] && s.has(r);\n        });\n      })() && (r.listeners = !0), this.notify({ ...r,\n        ...t\n      });\n    }\n\n    updateQuery() {\n      const t = this.client.getQueryCache().build(this.client, this.options);\n      if (t === this.currentQuery) return;\n      const e = this.currentQuery;\n      this.currentQuery = t, this.currentQueryInitialState = t.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (null == e || e.removeObserver(this), t.addObserver(this));\n    }\n\n    onQueryUpdate(t) {\n      const e = {};\n      \"success\" === t.type ? e.onSuccess = !t.manual : \"error\" !== t.type || I(t.error) || (e.onError = !0), this.updateResult(e), this.hasListeners() && this.updateTimers();\n    }\n\n    notify(t) {\n      K.batch(() => {\n        var e, s, r, i;\n        if (t.onSuccess) null == (e = (s = this.options).onSuccess) || e.call(s, this.currentResult.data), null == (r = (i = this.options).onSettled) || r.call(i, this.currentResult.data, null);else if (t.onError) {\n          var n, a, o, u;\n          null == (n = (a = this.options).onError) || n.call(a, this.currentResult.error), null == (o = (u = this.options).onSettled) || o.call(u, void 0, this.currentResult.error);\n        }\n        t.listeners && this.listeners.forEach(t => {\n          t(this.currentResult);\n        }), t.cache && this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: \"observerResultsUpdated\"\n        });\n      });\n    }\n\n  }\n\n  function X(t, e) {\n    return function (t, e) {\n      return !(!1 === e.enabled || t.state.dataUpdatedAt || \"error\" === t.state.status && !1 === e.retryOnMount);\n    }(t, e) || t.state.dataUpdatedAt > 0 && Y(t, e, e.refetchOnMount);\n  }\n\n  function Y(t, e, s) {\n    if (!1 !== e.enabled) {\n      const r = \"function\" == typeof s ? s(t) : s;\n      return \"always\" === r || !1 !== r && $(t, e);\n    }\n\n    return !1;\n  }\n\n  function Z(t, e, s, r) {\n    return !1 !== s.enabled && (t !== e || !1 === r.enabled) && (!s.suspense || \"error\" !== t.state.status) && $(t, s);\n  }\n\n  function $(t, e) {\n    return t.isStaleByTime(e.staleTime);\n  }\n\n  class tt extends n {\n    constructor(t, e) {\n      super(), this.client = t, this.queries = [], this.result = [], this.observers = [], this.observersMap = {}, e && this.setQueries(e);\n    }\n\n    onSubscribe() {\n      1 === this.listeners.length && this.observers.forEach(t => {\n        t.subscribe(e => {\n          this.onUpdate(t, e);\n        });\n      });\n    }\n\n    onUnsubscribe() {\n      this.listeners.length || this.destroy();\n    }\n\n    destroy() {\n      this.listeners = [], this.observers.forEach(t => {\n        t.destroy();\n      });\n    }\n\n    setQueries(t, e) {\n      this.queries = t, K.batch(() => {\n        const t = this.observers,\n              s = this.findMatchingObservers(this.queries);\n        s.forEach(t => t.observer.setOptions(t.defaultedQueryOptions, e));\n        const r = s.map(t => t.observer),\n              i = Object.fromEntries(r.map(t => [t.options.queryHash, t])),\n              n = r.map(t => t.getCurrentResult()),\n              a = r.some((e, s) => e !== t[s]);\n        (t.length !== r.length || a) && (this.observers = r, this.observersMap = i, this.result = n, this.hasListeners() && (c(t, r).forEach(t => {\n          t.destroy();\n        }), c(r, t).forEach(t => {\n          t.subscribe(e => {\n            this.onUpdate(t, e);\n          });\n        }), this.notify()));\n      });\n    }\n\n    getCurrentResult() {\n      return this.result;\n    }\n\n    getOptimisticResult(t) {\n      return this.findMatchingObservers(t).map(t => t.observer.getOptimisticResult(t.defaultedQueryOptions));\n    }\n\n    findMatchingObservers(t) {\n      const e = this.observers,\n            s = t.map(t => this.client.defaultQueryOptions(t)),\n            r = s.flatMap(t => {\n        const s = e.find(e => e.options.queryHash === t.queryHash);\n        return null != s ? [{\n          defaultedQueryOptions: t,\n          observer: s\n        }] : [];\n      }),\n            i = r.map(t => t.defaultedQueryOptions.queryHash),\n            n = s.filter(t => !i.includes(t.queryHash)),\n            a = e.filter(t => !r.some(e => e.observer === t)),\n            o = t => {\n        const e = this.client.defaultQueryOptions(t),\n              s = this.observersMap[e.queryHash];\n        return null != s ? s : new V(this.client, e);\n      },\n            u = n.map((t, e) => {\n        if (t.keepPreviousData) {\n          const s = a[e];\n          if (void 0 !== s) return {\n            defaultedQueryOptions: t,\n            observer: s\n          };\n        }\n\n        return {\n          defaultedQueryOptions: t,\n          observer: o(t)\n        };\n      });\n\n      return r.concat(u).sort((t, e) => s.indexOf(t.defaultedQueryOptions) - s.indexOf(e.defaultedQueryOptions));\n    }\n\n    onUpdate(t, e) {\n      const s = this.observers.indexOf(t);\n      -1 !== s && (this.result = function (t, e, s) {\n        const r = t.slice(0);\n        return r[e] = s, r;\n      }(this.result, s, e), this.notify());\n    }\n\n    notify() {\n      K.batch(() => {\n        this.listeners.forEach(t => {\n          t(this.result);\n        });\n      });\n    }\n\n  }\n\n  class et extends V {\n    constructor(t, e) {\n      super(t, e);\n    }\n\n    bindMethods() {\n      super.bindMethods(), this.fetchNextPage = this.fetchNextPage.bind(this), this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n    }\n\n    setOptions(t, e) {\n      super.setOptions({ ...t,\n        behavior: G()\n      }, e);\n    }\n\n    getOptimisticResult(t) {\n      return t.behavior = G(), super.getOptimisticResult(t);\n    }\n\n    fetchNextPage() {\n      let {\n        pageParam: t,\n        ...e\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.fetch({ ...e,\n        meta: {\n          fetchMore: {\n            direction: \"forward\",\n            pageParam: t\n          }\n        }\n      });\n    }\n\n    fetchPreviousPage() {\n      let {\n        pageParam: t,\n        ...e\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.fetch({ ...e,\n        meta: {\n          fetchMore: {\n            direction: \"backward\",\n            pageParam: t\n          }\n        }\n      });\n    }\n\n    createResult(t, e) {\n      var s, r, i, n, a, o;\n      const {\n        state: u\n      } = t;\n      return { ...super.createResult(t, e),\n        fetchNextPage: this.fetchNextPage,\n        fetchPreviousPage: this.fetchPreviousPage,\n        hasNextPage: z(e, null == (s = u.data) ? void 0 : s.pages),\n        hasPreviousPage: J(e, null == (r = u.data) ? void 0 : r.pages),\n        isFetchingNextPage: \"fetching\" === u.fetchStatus && \"forward\" === (null == (i = u.fetchMeta) || null == (n = i.fetchMore) ? void 0 : n.direction),\n        isFetchingPreviousPage: \"fetching\" === u.fetchStatus && \"backward\" === (null == (a = u.fetchMeta) || null == (o = a.fetchMore) ? void 0 : o.direction)\n      };\n    }\n\n  }\n\n  class st extends n {\n    constructor(t, e) {\n      super(), this.client = t, this.setOptions(e), this.bindMethods(), this.updateResult();\n    }\n\n    bindMethods() {\n      this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);\n    }\n\n    setOptions(t) {\n      this.options = this.client.defaultMutationOptions(t);\n    }\n\n    onUnsubscribe() {\n      var t;\n      this.listeners.length || null == (t = this.currentMutation) || t.removeObserver(this);\n    }\n\n    onMutationUpdate(t) {\n      this.updateResult();\n      const e = {\n        listeners: !0\n      };\n      \"success\" === t.type ? e.onSuccess = !0 : \"error\" === t.type && (e.onError = !0), this.notify(e);\n    }\n\n    getCurrentResult() {\n      return this.currentResult;\n    }\n\n    reset() {\n      this.currentMutation = void 0, this.updateResult(), this.notify({\n        listeners: !0\n      });\n    }\n\n    mutate(t, e) {\n      return this.mutateOptions = e, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n        variables: void 0 !== t ? t : this.options.variables\n      }), this.currentMutation.addObserver(this), this.currentMutation.execute();\n    }\n\n    updateResult() {\n      const t = this.currentMutation ? this.currentMutation.state : {\n        context: void 0,\n        data: void 0,\n        error: null,\n        failureCount: 0,\n        isPaused: !1,\n        status: \"idle\",\n        variables: void 0\n      },\n            e = { ...t,\n        isLoading: \"loading\" === t.status,\n        isSuccess: \"success\" === t.status,\n        isError: \"error\" === t.status,\n        isIdle: \"idle\" === t.status,\n        mutate: this.mutate,\n        reset: this.reset\n      };\n      this.currentResult = e;\n    }\n\n    notify(t) {\n      K.batch(() => {\n        var e, s, r, i;\n        if (this.mutateOptions) if (t.onSuccess) null == (e = (s = this.mutateOptions).onSuccess) || e.call(s, this.currentResult.data, this.currentResult.variables, this.currentResult.context), null == (r = (i = this.mutateOptions).onSettled) || r.call(i, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);else if (t.onError) {\n          var n, a, o, u;\n          null == (n = (a = this.mutateOptions).onError) || n.call(a, this.currentResult.error, this.currentResult.variables, this.currentResult.context), null == (o = (u = this.mutateOptions).onSettled) || o.call(u, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n        t.listeners && this.listeners.forEach(t => {\n          t(this.currentResult);\n        });\n      });\n    }\n\n  }\n\n  function rt(t) {\n    return t.state.isPaused;\n  }\n\n  function it(t) {\n    return \"success\" === t.state.status;\n  }\n\n  function nt(t, e, s) {\n    if (\"object\" != typeof e || null === e) return;\n    const r = t.getMutationCache(),\n          i = t.getQueryCache(),\n          n = e.mutations || [],\n          a = e.queries || [];\n    n.forEach(e => {\n      var i;\n      r.build(t, { ...(null == s || null == (i = s.defaultOptions) ? void 0 : i.mutations),\n        mutationKey: e.mutationKey\n      }, e.state);\n    }), a.forEach(e => {\n      var r;\n      const n = i.get(e.queryHash);\n      n ? n.state.dataUpdatedAt < e.state.dataUpdatedAt && n.setState(e.state) : i.build(t, { ...(null == s || null == (r = s.defaultOptions) ? void 0 : r.queries),\n        queryKey: e.queryKey,\n        queryHash: e.queryHash\n      }, e.state);\n    });\n  }\n\n  const at = i.createContext(void 0),\n        ot = i.createContext(!1);\n\n  function ut(t, e) {\n    return t || (e && \"undefined\" != typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = at), window.ReactQueryClientContext) : at);\n  }\n\n  const ct = function () {\n    let {\n      context: t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const e = i.useContext(ut(t, i.useContext(ot)));\n    if (!e) throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    return e;\n  },\n        ht = i.createContext(!1),\n        lt = () => i.useContext(ht),\n        dt = ht.Provider;\n\n  function ft() {\n    let t = !1;\n    return {\n      clearReset: () => {\n        t = !1;\n      },\n      reset: () => {\n        t = !0;\n      },\n      isReset: () => t\n    };\n  }\n\n  const pt = i.createContext(ft()),\n        yt = () => i.useContext(pt);\n\n  function vt(t, e) {\n    return \"function\" == typeof t ? t(...e) : !!t;\n  }\n\n  function mt(t, e) {\n    const r = ct({\n      context: t.context\n    }),\n          n = lt(),\n          a = yt(),\n          o = r.defaultQueryOptions(t);\n    o._optimisticResults = n ? \"isRestoring\" : \"optimistic\", o.onError && (o.onError = K.batchCalls(o.onError)), o.onSuccess && (o.onSuccess = K.batchCalls(o.onSuccess)), o.onSettled && (o.onSettled = K.batchCalls(o.onSettled)), o.suspense && \"number\" != typeof o.staleTime && (o.staleTime = 1e3), (o.suspense || o.useErrorBoundary) && (a.isReset() || (o.retryOnMount = !1));\n    const [u] = i.useState(() => new e(r, o)),\n          c = u.getOptimisticResult(o);\n    if (s.useSyncExternalStore(i.useCallback(t => n ? () => {} : u.subscribe(K.batchCalls(t)), [u, n]), () => u.getCurrentResult(), () => u.getCurrentResult()), i.useEffect(() => {\n      a.clearReset();\n    }, [a]), i.useEffect(() => {\n      u.setOptions(o, {\n        listeners: !1\n      });\n    }, [o, u]), o.suspense && c.isLoading && c.isFetching && !n) throw u.fetchOptimistic(o).then(_ref => {\n      let {\n        data: t\n      } = _ref;\n      null == o.onSuccess || o.onSuccess(t), null == o.onSettled || o.onSettled(t, null);\n    }).catch(t => {\n      a.clearReset(), null == o.onError || o.onError(t), null == o.onSettled || o.onSettled(void 0, t);\n    });\n    if (c.isError && !a.isReset() && !c.isFetching && vt(o.useErrorBoundary, [c.error, u.getCurrentQuery()])) throw c.error;\n    return o.notifyOnChangeProps ? c : u.trackResult(c);\n  }\n\n  function bt(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const s = ct({\n      context: e.context\n    }),\n          r = i.useRef(e);\n    r.current = e, i.useMemo(() => {\n      t && nt(s, t, r.current);\n    }, [s, t]);\n  }\n\n  function gt() {}\n\n  t.CancelledError = D, t.Hydrate = _ref2 => {\n    let {\n      children: t,\n      options: e,\n      state: s\n    } = _ref2;\n    return bt(s, e), t;\n  }, t.InfiniteQueryObserver = et, t.IsRestoringProvider = dt, t.MutationCache = B, t.MutationObserver = st, t.QueriesObserver = tt, t.QueryCache = j, t.QueryClient = class {\n    constructor() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.queryCache = t.queryCache || new j(), this.mutationCache = t.mutationCache || new B(), this.logger = t.logger || T, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [];\n    }\n\n    mount() {\n      this.unsubscribeFocus = M.subscribe(() => {\n        M.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus());\n      }), this.unsubscribeOnline = w.subscribe(() => {\n        w.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline());\n      });\n    }\n\n    unmount() {\n      var t, e;\n      null == (t = this.unsubscribeFocus) || t.call(this), null == (e = this.unsubscribeOnline) || e.call(this);\n    }\n\n    isFetching(t, e) {\n      const [s] = f(t, e);\n      return s.fetchStatus = \"fetching\", this.queryCache.findAll(s).length;\n    }\n\n    isMutating(t) {\n      return this.mutationCache.findAll({ ...t,\n        fetching: !0\n      }).length;\n    }\n\n    getQueryData(t, e) {\n      var s;\n      return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state.data;\n    }\n\n    getQueriesData(t) {\n      return this.getQueryCache().findAll(t).map(_ref3 => {\n        let {\n          queryKey: t,\n          state: e\n        } = _ref3;\n        return [t, e.data];\n      });\n    }\n\n    setQueryData(t, e, s) {\n      const r = this.queryCache.find(t),\n            i = function (t, e) {\n        return \"function\" == typeof t ? t(e) : t;\n      }(e, null == r ? void 0 : r.state.data);\n\n      if (void 0 === i) return;\n      const n = l(t),\n            a = this.defaultQueryOptions(n);\n      return this.queryCache.build(this, a).setData(i, { ...s,\n        manual: !0\n      });\n    }\n\n    setQueriesData(t, e, s) {\n      return K.batch(() => this.getQueryCache().findAll(t).map(_ref4 => {\n        let {\n          queryKey: t\n        } = _ref4;\n        return [t, this.setQueryData(t, e, s)];\n      }));\n    }\n\n    getQueryState(t, e) {\n      var s;\n      return null == (s = this.queryCache.find(t, e)) ? void 0 : s.state;\n    }\n\n    removeQueries(t, e) {\n      const [s] = f(t, e),\n            r = this.queryCache;\n      K.batch(() => {\n        r.findAll(s).forEach(t => {\n          r.remove(t);\n        });\n      });\n    }\n\n    resetQueries(t, e, s) {\n      const [r, i] = f(t, e, s),\n            n = this.queryCache,\n            a = {\n        type: \"active\",\n        ...r\n      };\n      return K.batch(() => (n.findAll(r).forEach(t => {\n        t.reset();\n      }), this.refetchQueries(a, i)));\n    }\n\n    cancelQueries(t, e, s) {\n      const [r, i = {}] = f(t, e, s);\n      void 0 === i.revert && (i.revert = !0);\n      const n = K.batch(() => this.queryCache.findAll(r).map(t => t.cancel(i)));\n      return Promise.all(n).then(o).catch(o);\n    }\n\n    invalidateQueries(t, e, s) {\n      const [r, i] = f(t, e, s);\n      return K.batch(() => {\n        var t, e;\n        if (this.queryCache.findAll(r).forEach(t => {\n          t.invalidate();\n        }), \"none\" === r.refetchType) return Promise.resolve();\n        const s = { ...r,\n          type: null != (t = null != (e = r.refetchType) ? e : r.type) ? t : \"active\"\n        };\n        return this.refetchQueries(s, i);\n      });\n    }\n\n    refetchQueries(t, e, s) {\n      const [r, i] = f(t, e, s),\n            n = K.batch(() => this.queryCache.findAll(r).filter(t => !t.isDisabled()).map(t => {\n        var e;\n        return t.fetch(void 0, { ...i,\n          cancelRefetch: null == (e = null == i ? void 0 : i.cancelRefetch) || e,\n          meta: {\n            refetchPage: r.refetchPage\n          }\n        });\n      }));\n      let a = Promise.all(n).then(o);\n      return null != i && i.throwOnError || (a = a.catch(o)), a;\n    }\n\n    fetchQuery(t, e, s) {\n      const r = l(t, e, s),\n            i = this.defaultQueryOptions(r);\n      void 0 === i.retry && (i.retry = !1);\n      const n = this.queryCache.build(this, i);\n      return n.isStaleByTime(i.staleTime) ? n.fetch(i) : Promise.resolve(n.state.data);\n    }\n\n    prefetchQuery(t, e, s) {\n      return this.fetchQuery(t, e, s).then(o).catch(o);\n    }\n\n    fetchInfiniteQuery(t, e, s) {\n      const r = l(t, e, s);\n      return r.behavior = G(), this.fetchQuery(r);\n    }\n\n    prefetchInfiniteQuery(t, e, s) {\n      return this.fetchInfiniteQuery(t, e, s).then(o).catch(o);\n    }\n\n    resumePausedMutations() {\n      return this.mutationCache.resumePausedMutations();\n    }\n\n    getQueryCache() {\n      return this.queryCache;\n    }\n\n    getMutationCache() {\n      return this.mutationCache;\n    }\n\n    getLogger() {\n      return this.logger;\n    }\n\n    getDefaultOptions() {\n      return this.defaultOptions;\n    }\n\n    setDefaultOptions(t) {\n      this.defaultOptions = t;\n    }\n\n    setQueryDefaults(t, e) {\n      const s = this.queryDefaults.find(e => b(t) === b(e.queryKey));\n      s ? s.defaultOptions = e : this.queryDefaults.push({\n        queryKey: t,\n        defaultOptions: e\n      });\n    }\n\n    getQueryDefaults(t) {\n      if (!t) return;\n      const e = this.queryDefaults.find(e => g(t, e.queryKey));\n      return null == e ? void 0 : e.defaultOptions;\n    }\n\n    setMutationDefaults(t, e) {\n      const s = this.mutationDefaults.find(e => b(t) === b(e.mutationKey));\n      s ? s.defaultOptions = e : this.mutationDefaults.push({\n        mutationKey: t,\n        defaultOptions: e\n      });\n    }\n\n    getMutationDefaults(t) {\n      if (!t) return;\n      const e = this.mutationDefaults.find(e => g(t, e.mutationKey));\n      return null == e ? void 0 : e.defaultOptions;\n    }\n\n    defaultQueryOptions(t) {\n      if (null != t && t._defaulted) return t;\n      const e = { ...this.defaultOptions.queries,\n        ...this.getQueryDefaults(null == t ? void 0 : t.queryKey),\n        ...t,\n        _defaulted: !0\n      };\n      return !e.queryHash && e.queryKey && (e.queryHash = m(e.queryKey, e)), void 0 === e.refetchOnReconnect && (e.refetchOnReconnect = \"always\" !== e.networkMode), void 0 === e.useErrorBoundary && (e.useErrorBoundary = !!e.suspense), e;\n    }\n\n    defaultMutationOptions(t) {\n      return null != t && t._defaulted ? t : { ...this.defaultOptions.mutations,\n        ...this.getMutationDefaults(null == t ? void 0 : t.mutationKey),\n        ...t,\n        _defaulted: !0\n      };\n    }\n\n    clear() {\n      this.queryCache.clear(), this.mutationCache.clear();\n    }\n\n  }, t.QueryClientProvider = _ref5 => {\n    let {\n      client: t,\n      children: e,\n      context: s,\n      contextSharing: r = !1\n    } = _ref5;\n    i.useEffect(() => (t.mount(), () => {\n      t.unmount();\n    }), [t]);\n    const n = ut(s, r);\n    return i.createElement(ot.Provider, {\n      value: !s && r\n    }, i.createElement(n.Provider, {\n      value: t\n    }, e));\n  }, t.QueryErrorResetBoundary = _ref6 => {\n    let {\n      children: t\n    } = _ref6;\n    const [e] = i.useState(() => ft());\n    return i.createElement(pt.Provider, {\n      value: e\n    }, \"function\" == typeof t ? t(e) : t);\n  }, t.QueryObserver = V, t.defaultContext = at, t.dehydrate = function (t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const s = [],\n          r = [];\n\n    if (!1 !== e.dehydrateMutations) {\n      const r = e.shouldDehydrateMutation || rt;\n      t.getMutationCache().getAll().forEach(t => {\n        r(t) && s.push(function (t) {\n          return {\n            mutationKey: t.options.mutationKey,\n            state: t.state\n          };\n        }(t));\n      });\n    }\n\n    if (!1 !== e.dehydrateQueries) {\n      const s = e.shouldDehydrateQuery || it;\n      t.getQueryCache().getAll().forEach(t => {\n        s(t) && r.push(function (t) {\n          return {\n            state: t.state,\n            queryKey: t.queryKey,\n            queryHash: t.queryHash\n          };\n        }(t));\n      });\n    }\n\n    return {\n      mutations: s,\n      queries: r\n    };\n  }, t.focusManager = M, t.hashQueryKey = b, t.hydrate = nt, t.isCancelledError = I, t.isError = function (t) {\n    return t instanceof Error;\n  }, t.notifyManager = K, t.onlineManager = w, t.parseFilterArgs = f, t.parseMutationArgs = d, t.parseMutationFilterArgs = p, t.parseQueryArgs = l, t.useHydrate = bt, t.useInfiniteQuery = function (t, e, s) {\n    return mt(l(t, e, s), et);\n  }, t.useIsFetching = function (t, e, r) {\n    const [n, a = {}] = f(t, e, r),\n          o = ct({\n      context: a.context\n    }),\n          u = o.getQueryCache();\n    return s.useSyncExternalStore(i.useCallback(t => u.subscribe(K.batchCalls(t)), [u]), () => o.isFetching(n), () => o.isFetching(n));\n  }, t.useIsMutating = function (t, e, r) {\n    const [n, a = {}] = p(t, e, r),\n          o = ct({\n      context: a.context\n    }),\n          u = o.getMutationCache();\n    return s.useSyncExternalStore(i.useCallback(t => u.subscribe(K.batchCalls(t)), [u]), () => o.isMutating(n), () => o.isMutating(n));\n  }, t.useIsRestoring = lt, t.useMutation = function (t, e, r) {\n    const n = d(t, e, r),\n          a = ct({\n      context: n.context\n    }),\n          [o] = i.useState(() => new st(a, n));\n    i.useEffect(() => {\n      o.setOptions(n);\n    }, [o, n]);\n    const u = s.useSyncExternalStore(i.useCallback(t => o.subscribe(K.batchCalls(t)), [o]), () => o.getCurrentResult(), () => o.getCurrentResult()),\n          c = i.useCallback((t, e) => {\n      o.mutate(t, e).catch(gt);\n    }, [o]);\n    if (u.error && vt(o.options.useErrorBoundary, [u.error])) throw u.error;\n    return { ...u,\n      mutate: c,\n      mutateAsync: u.mutate\n    };\n  }, t.useQueries = function (_ref7) {\n    let {\n      queries: t,\n      context: e\n    } = _ref7;\n    const r = ct({\n      context: e\n    }),\n          n = lt(),\n          a = i.useMemo(() => t.map(t => {\n      const e = r.defaultQueryOptions(t);\n      return e._optimisticResults = n ? \"isRestoring\" : \"optimistic\", e;\n    }), [t, r, n]),\n          [o] = i.useState(() => new tt(r, a)),\n          u = o.getOptimisticResult(a);\n    return s.useSyncExternalStore(i.useCallback(t => n ? () => {} : o.subscribe(K.batchCalls(t)), [o, n]), () => o.getCurrentResult(), () => o.getCurrentResult()), i.useEffect(() => {\n      o.setQueries(a, {\n        listeners: !1\n      });\n    }, [a, o]), u;\n  }, t.useQuery = function (t, e, s) {\n    return mt(l(t, e, s), V);\n  }, t.useQueryClient = ct, t.useQueryErrorResetBoundary = yt, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"sources":["../../../query-core/build/esm/index.js","../../src/QueryClientProvider.tsx","../../src/isRestoring.tsx","../../src/QueryErrorResetBoundary.tsx","../../src/utils.ts","../../src/useBaseQuery.ts","../../src/Hydrate.tsx","../../src/useMutation.ts","../../src/useInfiniteQuery.ts","../../src/useIsFetching.ts","../../src/useIsMutating.ts","../../src/useQueries.ts","../../src/useQuery.ts"],"names":["Subscribable","constructor","this","listeners","subscribe","bind","listener","push","onSubscribe","filter","x","onUnsubscribe","hasListeners","length","isServer","window","noop","updater","input","isValidTimeout","value","Infinity","difference","array1","array2","indexOf","array","index","copy","slice","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","isPlainArray","aSize","bItems","bSize","equalItems","i","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","Error","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","AbortController","replaceData","prevData","data","isDataEqual","structuralSharing","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","includes","visibilityState","focusManager","onOnline","online","setOnline","isOnline","navigator","onLine","onlineManager","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","isRetryCancelled","isResolved","continueFn","promiseResolve","promiseReject","promise","outerResolve","outerReject","cancelOptions","reject","abort","shouldPause","onSuccess","onError","pause","continueResolve","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","continue","cancelRetry","continueRetry","defaultLogger","console","queue","transactions","notifyFn","batchNotifyFn","flush","schedule","args","originalQueue","batch","batchCalls","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","getDefaultState$1","meta","remove","setData","newData","dispatch","dataUpdatedAt","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","isInvalidated","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","_this$cache$config$on2","_this$cache$config2","action","_action$meta","_action$dataUpdatedAt","fetchFailureCount","dataUpdateCount","errorUpdateCount","errorUpdatedAt","notifyManager","onQueryUpdate","initialData","initialDataUpdatedAt","hasData","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","add","queryInMap","clear","getAll","findAll","event","Mutation","mutationId","mutationCache","getDefaultState","execute","async","executeMutation","_this$options$retry","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","onSettled","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onError","_this$options4","_this$options$onSettl2","_this$options5","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","_context$signal","aborted","_context$signal2","buildNewPages","param","page","previous","fetchPage","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","queryCache","queryDefaults","mutationDefaults","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isFetching","isMutating","getQueryData","_this$queryCache$find","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","functionalUpdate","parsedOptions","defaultedOptions","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","all","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","throwOnError","fetchQuery","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","refetchOnReconnect","useErrorBoundary","suspense","QueryObserver","trackedProps","Set","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","currentResult","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","_fetchOptions$cancelR","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","currentResultState","prevResultOptions","currentResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","keepPreviousData","isSuccess","select","selectFn","selectResult","placeholderData","isLoading","isError","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","shallowEqualObjects","defaultNotifyOptions","notifyOnChangeProps","size","includedProps","typedKey","has","retryOnMount","shouldLoadOnMount","refetchOnMount","field","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","newObserversMap","fromEntries","newResult","hasIndexChange","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$data","_state$data2","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","MutationObserver","mutate","_this$currentMutation","currentMutation","mutateOptions","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","hydrate","dehydratedState","dehydratedMutation","_options$defaultOptio","dehydratedQuery","_options$defaultOptio2","defaultContext","React","createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","useContext","children","useEffect","Context","Provider","IsRestoringContext","useIsRestoring","IsRestoringProvider","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","useState","shouldThrowError","_useErrorBoundary","params","useBaseQuery","Observer","isRestoring","errorResetBoundary","useSyncExternalStore","useCallback","onStoreChange","useHydrate","optionsRef","useRef","current","useMemo","mutateAsync","defaultedQueries"],"mappings":"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","sourcesContent":["/**\n * query-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Subscribable {\n  constructor() {\n    this.listeners = [];\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    this.listeners.push(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners = this.listeners.filter(x => x !== listener);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.length > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\n// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined';\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => array2.indexOf(x) === -1);\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    this.focused = focused;\n\n    if (focused) {\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        window.addEventListener('online', listener, false);\n        window.addEventListener('offline', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', listener);\n          window.removeEventListener('offline', listener);\n        };\n      }\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    this.online = online;\n\n    if (online) {\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(listener => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nconst defaultLogger = console;\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState$1(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState$1(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n        meta: options.meta\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.options = { ...config.defaultOptions,\n      ...config.options\n    };\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.meta = config.meta;\n    this.updateCacheTime(this.options.cacheTime);\n    this.scheduleGc();\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    if (this.retryer) {\n      this.retryer.continue();\n      return this.retryer.promise;\n    }\n\n    return this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: () => {\n          this.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, error, this.state.variables, this.state.context, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: state.failureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n  }\n\n}\n\nfunction infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject('Missing queryFn'));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    return this.createResult(query, options);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading: status === 'loading',\n      isSuccess: status === 'success',\n      isError: status === 'error',\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching: isFetching,\n      isRefetching: isFetching && status !== 'loading',\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n\n      if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = [];\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObservers.find(observer => observer.options.queryHash === defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = matchingObservers.map(match => match.defaultedQueryOptions.queryHash);\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.includes(defaultedOptions.queryHash));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObservers.some(match => match.observer === prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$data, _state$data2, _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward',\n      isFetchingPreviousPage: state.fetchStatus === 'fetching' && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward'\n    };\n  }\n\n}\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    this.options = this.client.defaultMutationOptions(options);\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.length) {\n      var _this$currentMutation;\n\n      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const result = { ...state,\n      isLoading: state.status === 'loading',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(listener => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\n// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\n\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\n\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(dehydratedQuery => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(dehydratedQuery.queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < dehydratedQuery.state.dataUpdatedAt) {\n        query.setState(dehydratedQuery.state);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey: dehydratedQuery.queryKey,\n      queryHash: dehydratedQuery.queryHash\n    }, dehydratedQuery.state);\n  });\n}\n\nexport { CancelledError, InfiniteQueryObserver, MutationCache, MutationObserver, QueriesObserver, QueryCache, QueryClient, QueryObserver, dehydrate, focusManager, hashQueryKey, hydrate, isCancelledError, isError, notifyManager, onlineManager, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\n\nimport { QueryClient } from '@tanstack/query-core'\nimport { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","import * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","import * as React from 'react'\n\n// CONTEXT\n\ninterface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport { QueryKey, notifyManager, QueryObserver } from '@tanstack/query-core'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\nimport { useIsRestoring } from './isRestoring'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false\n    }\n  }\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (\n    defaultedOptions.suspense &&\n    result.isLoading &&\n    result.isFetching &&\n    !isRestoring\n  ) {\n    throw observer\n      .fetchOptimistic(defaultedOptions)\n      .then(({ data }) => {\n        defaultedOptions.onSuccess?.(data as TData)\n        defaultedOptions.onSettled?.(data, null)\n      })\n      .catch((error) => {\n        errorResetBoundary.clearReset()\n        defaultedOptions.onError?.(error)\n        defaultedOptions.onSettled?.(undefined, error)\n      })\n  }\n\n  // Handle error boundary\n  if (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(defaultedOptions.useErrorBoundary, [\n      result.error,\n      observer.getCurrentQuery(),\n    ])\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","import * as React from 'react'\n\nimport { hydrate, HydrateOptions } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  parseMutationArgs,\n  MutationObserver,\n  MutationFunction,\n  MutationKey,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport { shouldThrowError } from './utils'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import {\n  QueryObserver,\n  InfiniteQueryObserver,\n  QueryFunction,\n  QueryKey,\n  parseQueryArgs,\n} from '@tanstack/query-core'\nimport { UseInfiniteQueryOptions, UseInfiniteQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","import * as React from 'react'\nimport {\n  QueryKey,\n  notifyManager,\n  parseFilterArgs,\n  QueryFilters,\n} from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  notifyManager,\n  MutationKey,\n  MutationFilters,\n  parseMutationFilterArgs,\n} from '@tanstack/query-core'\nimport { ContextOptions } from './types'\nimport { useQueryClient } from './QueryClientProvider'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n","import * as React from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n\nimport {\n  QueryKey,\n  QueryFunction,\n  notifyManager,\n  QueriesObserver,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  return result as QueriesResults<T>\n}\n","import {\n  parseQueryArgs,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport { DefinedUseQueryResult, UseQueryOptions, UseQueryResult } from './types'\nimport { useBaseQuery } from './useBaseQuery'\n\n// HOOK\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n"]},"metadata":{},"sourceType":"script"}