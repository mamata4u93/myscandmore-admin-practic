{"ast":null,"code":"import { useMemo, useRef, useCallback, useEffect } from 'react';\nimport lodashDebounce from 'lodash.debounce';\n\nvar createCallback = function createCallback(debounce, handleOnScroll, options) {\n  if (debounce) {\n    return lodashDebounce(handleOnScroll, debounce, options);\n  } else {\n    return handleOnScroll;\n  }\n};\n\nfunction useBottomScrollListener(onBottom, options) {\n  var _useMemo = useMemo(function () {\n    var _options$offset, _options$debounce, _options$debounceOpti, _options$triggerOnNoS;\n\n    return {\n      offset: (_options$offset = options === null || options === void 0 ? void 0 : options.offset) != null ? _options$offset : 0,\n      debounce: (_options$debounce = options === null || options === void 0 ? void 0 : options.debounce) != null ? _options$debounce : 200,\n      debounceOptions: (_options$debounceOpti = options === null || options === void 0 ? void 0 : options.debounceOptions) != null ? _options$debounceOpti : {\n        leading: true\n      },\n      triggerOnNoScroll: (_options$triggerOnNoS = options === null || options === void 0 ? void 0 : options.triggerOnNoScroll) != null ? _options$triggerOnNoS : false\n    };\n  }, [options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.debounce, options === null || options === void 0 ? void 0 : options.debounceOptions, options === null || options === void 0 ? void 0 : options.triggerOnNoScroll]),\n      offset = _useMemo.offset,\n      triggerOnNoScroll = _useMemo.triggerOnNoScroll,\n      debounce = _useMemo.debounce,\n      debounceOptions = _useMemo.debounceOptions;\n\n  var debouncedOnBottom = useMemo(function () {\n    return createCallback(debounce, onBottom, debounceOptions);\n  }, [debounce, onBottom]);\n  var containerRef = useRef(null);\n  var handleOnScroll = useCallback(function () {\n    if (containerRef.current != null) {\n      var scrollNode = containerRef.current;\n      var scrollContainerBottomPosition = Math.round(scrollNode.scrollTop + scrollNode.clientHeight);\n      var scrollPosition = Math.round(scrollNode.scrollHeight - offset);\n\n      if (scrollPosition <= scrollContainerBottomPosition) {\n        debouncedOnBottom();\n      }\n    } else {\n      var _scrollNode = document.scrollingElement || document.documentElement;\n\n      var _scrollContainerBottomPosition = Math.round(_scrollNode.scrollTop + window.innerHeight);\n\n      var _scrollPosition = Math.round(_scrollNode.scrollHeight - offset);\n\n      if (_scrollPosition <= _scrollContainerBottomPosition) {\n        debouncedOnBottom();\n      }\n    }\n  }, [offset, onBottom, containerRef.current]);\n  useEffect(function () {\n    var ref = containerRef.current;\n\n    if (ref != null) {\n      ref.addEventListener('scroll', handleOnScroll);\n    } else {\n      window.addEventListener('scroll', handleOnScroll);\n    }\n\n    if (triggerOnNoScroll) {\n      handleOnScroll();\n    }\n\n    return function () {\n      if (ref != null) {\n        ref.removeEventListener('scroll', handleOnScroll);\n      } else {\n        window.removeEventListener('scroll', handleOnScroll);\n      }\n    };\n  }, [handleOnScroll, debounce]);\n  return containerRef;\n}\n\nvar BottomScrollListener = function BottomScrollListener(_ref) {\n  var children = _ref.children,\n      onBottom = _ref.onBottom,\n      offset = _ref.offset,\n      debounce = _ref.debounce,\n      debounceOptions = _ref.debounceOptions,\n      triggerOnNoScroll = _ref.triggerOnNoScroll;\n  var optionalScrollContainerRef = useBottomScrollListener(onBottom, {\n    offset: offset,\n    debounce: debounce,\n    debounceOptions: debounceOptions,\n    triggerOnNoScroll: triggerOnNoScroll\n  });\n  if (!children) return null;else if (typeof children === 'function') return children(optionalScrollContainerRef);else return children;\n};\n\nexport { BottomScrollListener, useBottomScrollListener };","map":{"version":3,"sources":["../src/hook/index.tsx","../src/component/index.tsx"],"names":["createCallback","lodashDebounce","offset","triggerOnNoScroll","debounce","debounceOptions","useMemo","options","leading","debouncedOnBottom","containerRef","useRef","handleOnScroll","useCallback","scrollNode","scrollContainerBottomPosition","Math","scrollPosition","document","window","useEffect","ref","BottomScrollListener","children","onBottom","optionalScrollContainerRef","useBottomScrollListener"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef, useMemo, RefObject } from 'react';\nimport lodashDebounce from 'lodash.debounce';\n\nexport type DebounceOptions = Parameters<typeof lodashDebounce>[2];\n\nconst createCallback = (debounce: number, handleOnScroll: () => void, options: DebounceOptions): (() => void) => {\n  if (debounce) {\n    return lodashDebounce(handleOnScroll, debounce, options);\n  } else {\n    return handleOnScroll;\n  }\n};\n\n/**\n * @description\n *  A react hook that invokes a callback when user scrolls to the bottom\n *\n * @param onBottom Required callback that will be invoked when scrolled to bottom\n * @param {Object} options - Optional parameters\n * @param {number} [options.offset=0] - Offset from bottom of page in pixels. E.g. 300 will trigger onBottom 300px from the bottom of the page\n * @param {number} [options.debounce=200] - Optional debounce in milliseconds, defaults to 200ms\n * @param {DebounceOptions} [options.debounceOptions={leading=true}] - Options passed to lodash.debounce, see https://lodash.com/docs/4.17.15#debounce\n * @param {boolean} [options.triggerOnNoScroll=false] - Triggers the onBottom callback when the page has no scrollbar\n * @returns {RefObject} ref - If passed to a element as a ref, e.g. a div it will register scrolling to the bottom of that div instead of document viewport\n */\nfunction useBottomScrollListener<T extends HTMLElement>(\n  onBottom: () => void,\n  options?: {\n    offset?: number;\n    debounce?: number;\n    debounceOptions?: DebounceOptions;\n    triggerOnNoScroll?: boolean;\n  },\n): RefObject<T> {\n  const { offset, triggerOnNoScroll, debounce, debounceOptions } = useMemo(\n    () => ({\n      offset: options?.offset ?? 0,\n      debounce: options?.debounce ?? 200,\n      debounceOptions: options?.debounceOptions ?? { leading: true },\n      triggerOnNoScroll: options?.triggerOnNoScroll ?? false,\n    }),\n    [options?.offset, options?.debounce, options?.debounceOptions, options?.triggerOnNoScroll],\n  );\n\n  const debouncedOnBottom = useMemo(() => createCallback(debounce, onBottom, debounceOptions), [debounce, onBottom]);\n  const containerRef = useRef<T>(null);\n  const handleOnScroll = useCallback(() => {\n    if (containerRef.current != null) {\n      const scrollNode: T = containerRef.current;\n      const scrollContainerBottomPosition = Math.round(scrollNode.scrollTop + scrollNode.clientHeight);\n      const scrollPosition = Math.round(scrollNode.scrollHeight - offset);\n\n      if (scrollPosition <= scrollContainerBottomPosition) {\n        debouncedOnBottom();\n      }\n    } else {\n      const scrollNode: Element = document.scrollingElement || document.documentElement;\n      const scrollContainerBottomPosition = Math.round(scrollNode.scrollTop + window.innerHeight);\n      const scrollPosition = Math.round(scrollNode.scrollHeight - offset);\n\n      if (scrollPosition <= scrollContainerBottomPosition) {\n        debouncedOnBottom();\n      }\n    }\n    // ref dependency needed for the tests, doesn't matter for normal execution\n  }, [offset, onBottom, containerRef.current]);\n\n  useEffect((): (() => void) => {\n    const ref: T | null = containerRef.current;\n    if (ref != null) {\n      ref.addEventListener('scroll', handleOnScroll);\n    } else {\n      window.addEventListener('scroll', handleOnScroll);\n    }\n\n    if (triggerOnNoScroll) {\n      handleOnScroll();\n    }\n\n    return () => {\n      if (ref != null) {\n        ref.removeEventListener('scroll', handleOnScroll);\n      } else {\n        window.removeEventListener('scroll', handleOnScroll);\n      }\n    };\n  }, [handleOnScroll, debounce]);\n\n  return containerRef;\n}\n\nexport default useBottomScrollListener;\n","import { MutableRefObject } from 'react';\nimport useBottomScrollListener, { DebounceOptions } from '../hook';\n\nexport interface BottomScrollListenerProps {\n  /**\n   * Required callback that will be invoked when scrolled to bottom\n   */\n  onBottom: () => void;\n\n  /**\n   * Offset from bottom of page in pixels. E.g. 300 will trigger onBottom 300px from the bottom of the page\n   */\n  offset?: number;\n\n  /**\n   * Optional debounce in milliseconds, defaults to 200ms\n   */\n  debounce?: number;\n\n  /**\n   * Options passed to lodash.debounce, see https://lodash.com/docs/4.17.15#debounce\n   */\n  debounceOptions?: DebounceOptions;\n\n  /**\n   * Triggers the onBottom callback when the page has no scrollbar, defaults to false\n   */\n  triggerOnNoScroll?: boolean;\n\n  /**\n   *   Optional children to be rendered.\n   *\n   *   If children passed is a function, that function will be passed a React.RefObject<HTMLElement>\n   *   that ref shall be passed to a child tag that will be used for the scrolling container.\n   * */\n  children?:\n    | JSX.Element\n    | (<T>(ref: ((instance: T | null) => void) | MutableRefObject<T | null> | null) => JSX.Element);\n}\n\n/**\n * A simple React component that lets you listen for when you have scrolled to the bottom.\n *\n * @param {BottomScrollListenerProps} props\n */\nconst BottomScrollListener = ({\n  children,\n  onBottom,\n  offset,\n  debounce,\n  debounceOptions,\n  triggerOnNoScroll,\n}: BottomScrollListenerProps): JSX.Element | null => {\n  const optionalScrollContainerRef = useBottomScrollListener(onBottom, {\n    offset,\n    debounce,\n    debounceOptions,\n    triggerOnNoScroll,\n  });\n\n  if (!children) return null;\n  else if (typeof children === 'function') return children(optionalScrollContainerRef);\n  else return children;\n};\n\nexport default BottomScrollListener;\n"]},"metadata":{},"sourceType":"module"}